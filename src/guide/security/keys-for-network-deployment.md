# Keys for Deploying a Network

Keeping in mind what we said [about public key cryptography earlier](./public-key-cryptography), note that if you're deploying your own network, you should change the keys in all three of the configuration files:

1. Peer configuration file: [`configs/peer/config.json`](../configure/peer-configuration)

2. Client configuration file: [`configs/client_cli/config.json `](../configure/client-configuration)

3. Genesis block file: [`configs/peer/genesis.json`](../configure/genesis)

## Setting Keys For a New Network

### 1. Generate New Key Pairs

To generate a new key pair, a wide variety of methods can be used. However, within the Iroha 2 framework, any of the following methods can be utilized conveniently:

Run the built-in `kagami` program by executing the following:

```bash

$ cargo run --bin kagami -- crypto --json

```
::: tip Note

The output cryptographic keys generated by `kagami` are customizable by using preferences. Note that in the example above the `--json` parameter is specified to generate a key pair in the JSON format.

For more information about generating cryptographic key pairs with `kagami`, see [Generating Cryptographic Keys with Kagami](./generating-cryptographic-keys#kagami).

For more details, see [`kagami` documentation on GitHub](https://github.com/hyperledger/iroha/tree/iroha2-dev/tools/kagami#crypto).

:::

If you plan to use the generated `private_key` with one of our SDKs, note that even though cryptographic keys are commonly encoded using ASCII characters, both the `payload` value of the `private_key` and the string representation of the `public_key` are encoded as Hex.

### 2. Update Keys For Peers

If you want to set up your own network, you should change the keys for all your peers: in `peer/config.json` change `PUBLIC_KEY` and `PRIVATE_KEY` to the fresh pair. When you've done that, you should add the keys to the `TRUSTED_PEERS` array in the same configuration file. Every peer that wants to connect to the given peer from the outside must know its `PRIVATE_KEY` specified in the `TRUSTED_PEERS` section.

To create a minimum [BFT](guide/glossary.md#byzantine-fault-tolerance-bft) network one needs four peers, which means four different private keys split across four different configuration files (or environment variables).

Each peer must have their own `PUBLIC_KEY` and `PRIVATE_KEY` variables specified. All four of the public keys—including the peer that is being configured—must be added to the `TRUSTED_PEERS` array. The same `TRUSTED_PEERS` array must be copied across all four of the configuration files. If either one of the peers is missing, or there's an extraneous peer or one of the peers has the incorrect key, the network will fail to start.

After that, make sure that the peers agree on the `GENESIS_ACCOUNT` key pairs. Failure to do so will result in a network which cannot accept any transactions.

::: tip Note

Even though the private key for the genesis account is known to all peers, the account itself loses all privileges after the first block is committed.

:::

## 3. Register a non-genesis account

Finally, while the first client _could_ use the genesis account to register new users, it's not a great idea for most networks. You should, instead, register a non-genesis account (for example, _alice_@wonderland).

::: warning NB

`iroha_client_cli` currently processes all of its instructions in the JSON format, it also provides a dedicated instruction to unregister accounts.

If you plan on creating a private blockchain, you should consider writing your own client based on the `client` Rust crate, or any of the provided client libraries:

- [iroha-python](https://github.com/hyperledger/iroha-python),

- [iroha-iOS](https://github.com/hyperledger/iroha-ios),

- [iroha-java](https://github.com/hyperledger/iroha-java), or

- [iroha-javascript](https://github.com/hyperledger/iroha-javascript/tree/iroha2).

:::

## Keys on the Client Side

Every transaction is signed on behalf of some user, thus every operation requires a private key. The private key is to be kept secret (hence the name). As such the client program must handle the storage and secure signing of transactions. All clients are different, but `iroha_client_cli` is the least secure in this regard, as it stores the private key in multihash format in a plain text file and can optionally be overridden with an environment variable. This is only a reference implementation and _is not meant for production use_.

One needs to register a user on behalf of another already-registered user (just like you need to already have a pair of scissors to cut off the tag from a new one). Suppose that we want to register a user on behalf of `mad_hatter@wonderland`.

This entails generating a new private key, and sending its public key to the network so that said network can verify that it's that trustworthy `mad_hatter@wonderland`, and not some impostor (e.g. `mad_hatter@wünderbar`). In this case, the client application must prompt you, the user, to provide a key pair and verify the authenticity of the transactions:  belonging to `mad_hatter@wonderland` and having a signature derived from the appropriate public key.

For public key cryptography to work effectively, avoid re-using keys when you need to specify a new key. While in principle, there's nothing stopping you from doing that, an attacker will know that the private keys are identical, because they can usually see the public key. Private keys operate on slightly different principles than passwords, although most of the advice (to make them as random as possible, to never store them unencrypted, and to never send them to anyone under any circumstances), applies.
