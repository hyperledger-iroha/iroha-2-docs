# Keys for Deploying a Network

Keeping in mind what we said [about public key cryptography earlier](./public-key-cryptography.md), note that if you're deploying your own network, you should change the keys in all three of the configuration files:

  1. Peer configuration file: [`configs/peer/config.json`](../configure/peer-configuration.md)

  2. Client configuration file: [`configs/client_cli/config.json `](../configure/client-configuration.md)

  3. Genesis block file: [`configs/peer/genesis.json`](../configure/genesis.md)

## Setting Keys For a New Network {#setting-keys}

### 1. Generate New Key Pairs

To generate a new a key pair, a wide variety of methods can be used. However, within the Iroha 2 framework, any the following method can be utilized conveniently:

Run the in-built `kagami` program by executing the following:

```bash

$ cargo run --bin kagami -- crypto --json

```
::: tip Note

The output cryptographic keys generated by `kagami` are customizable by using preferences. Note that in the example above the `--json` parameter is specified to generate a key pair in the JSON format.

For more information on generating cryptographic key pairs with `kagami`, see [Generating Cryptographic Keys with Kagami](./generating-cryptographic-keys.md#kagami).

For more details, see [`kagami` documentation on GitHub](https://github.com/hyperledger/iroha/tree/iroha2-dev/tools/kagami#crypto).

:::

If you plan to use the generated `private_key` with one of our SDKs, note that even though cryptographic keys are commonly encoded using ASCII characters, both the `payload` value of the `private_key` and the string representation of the `public_key` are encoded as Hex.

### 2. Update Keys For Peers

If you want to set up your own network, you should change the keys for all your peers: in `peer/config.json` change `PUBLIC_KEY` and `PRIVATE_KEY` to the fresh pair. When you've done that, you should add the keys to the `TRUSTED_PEERS` array in the same configuration file. Every peer that wants to connect to the given peer from the outside must know its `PRIVATE_KEY` specified in the `TRUSTED_PEERS` section.

If a minimum viable [BFT](/guide/glossary.md#byzantine-fault-tolerance-bft) network is being utilized—since such a network utilizes _four_ peers—_four_ different (`config.json`) peer configuration files must be created.

Each peer must have their own `PUBLIC_KEY` and `PRIVATE_KEY` variables specified. All four of the public keys—including the peer that is being configured—must be added to the `TRUSTED_PEERS` array. The same `TRUSTED_PEERS` array must be copied across all four of the configuration files.

After that, make sure that the peers agree on the `GENESIS_ACCOUNT` key pairs.

::: tip Note

Even though the private key for the genesis account is known to all peers, the account itself loses all privileges after the first block is committed.

:::

### 3. Register a Non-Genesis Account

Finally, while the first client _could_ use the genesis account to register new users, it's not a great idea for private networks. You should, instead, register a non-genesis account (for example, _alice_@wonderland) and `unregister` the genesis account.

::: warning NB

`iroha_client_cli` currently doesn't support unregister instructions. If you plan on creating a private blockchain, you should consider writing your own client based on the `client` Rust crate, or any of the provided client libraries:
[iroha-python](https://github.com/hyperledger/iroha-python),
[iroha-iOS](https://github.com/hyperledger/iroha-ios),
[iroha-java](https://github.com/hyperledger/iroha-java), or
[iroha-javascript](https://github.com/hyperledger/iroha-javascript/tree/iroha2).

:::

## Keys on the Client Side {#client-side}

When delving into the realm of cryptographic keys' utilization on the client side, it's essential to grasp their significance in ensuring secure operations within Iroha 2.

Every transaction involves a signature representing a user, therefore every transaction requires a corresponding cryptographic key for authentication. However, this doesn't imply a constant manual key entry.

Consider this analogy: an existing user is required to register a new user—just as an existing pair of scissors is required to remove the tag from a new pair of scissors. However, in order to register a new user, you must also provide their unique _public_ key, so that the network can verify that the `mad_hatter@wonderland` user—and not some `mad_hatter@wunderland`—is indeed communicating with it. Here, this scenario does imply a one-time manual key entry.

In instances where Iroha's command-line interface (`iroha_client_cli`) prompts for a --key argument, it's prudent to consider generating a fresh key-pair, aligning with the security-enhancing principle of regularly renewing cryptographic keys.

::: tip Note

Any time `iroha_client_cli` asks you to provide it with a specific `--key` argument, it is advised to generate a new cryptographic key pair.

:::
